import sys
import os
import os.path as osp
import glob
from collections import OrderedDict

from bv_build.workers import BuildWorker
from bv_build.project_info import read_project_info
from bv_build.subprocess_utils import verbose_check_call


class BrainVISACMakeWorker(BuildWorker):
    sitecustomize_content = '''\
import os

for i in os.listdir(os.path.dirname(__file__)):
    if i.endswith('.py') and i != '__init__.py':
        module = i[:-3]
        __import__('sitecustomize.%s' % module)
'''
    @staticmethod
    def cmake_path(path):
        '''
        Convert a system path to a CMakeLists.txt compatible path.
        '''
        if sys.platform == 'win32':
            return path.replace( '\\', '/' )
        else :
            return path

    @staticmethod
    def cmake_command():
        if sys.platform == 'win32':
            return ['cmake', '-G', 'MSYS Makefiles']
        else:
            return ['cmake']
    
    @classmethod
    def start_configure(cls, dir_manager, verbose, release, debug):
        # Create a sitecustomize Python package that imports all modules it
        # contains during Python startup. This is mainly used to modify sys.path
        # to include pure Python components source (see module 
        # brainvisa.maker.build_models.pure_python). This package is used only
        # in build directory, it is not installed in packages (to date there is
        # one exception to this in axon component, see Axon's CMakeLists.txt).
        sitecustomize_dir = osp.join(dir_manager.directory, 'python', 'sitecustomize')
        if not osp.exists(sitecustomize_dir):
            os.makedirs(sitecustomize_dir)
        open(osp.join(sitecustomize_dir,'__init__.py'), 'w').write(
            cls.sitecustomize_content)
        # Remove existing sitecustomize.py (was generated by older Axon)
        for i in glob.glob(sitecustomize_dir + '.py*'):
            os.remove(i)
        dir_manager.cache.setdefault('workers',{}).setdefault('brainvisa-cmake',{})['components'] = OrderedDict()
        if release:
            build_type = ('RelWithDebInfo' if debug else 'Release')
        else:
            build_type = ('Debug' if debug else 'None')
        dir_manager.cache['workers']['brainvisa-cmake']['cmake_build_type'] = build_type
    
    @classmethod
    def configure_module(cls, dir_manager, verbose, module):
        source_directory = osp.join(dir_manager.directory, 'src', module)
        project_info = read_project_info(source_directory)
        if project_info is None:
            raise RuntimeError('Cannot find project information (e.g. version) in %s' % source_directory)
        project, component, version = project_info
        full_version = '%(major)s.%(minor)s.%(micro)s' % version
        print 'Configure module', module, full_version

        if module == 'brainvisa-cmake':
            build_dir = osp.join(dir_manager.directory, 'build_files', module)
            if not osp.exists(build_dir):
                os.makedirs(build_dir)
            command = cls.cmake_command()
            command += ['-DCMAKE_INSTALL_PREFIX=%s' % dir_manager.directory, source_directory]
            verbose_check_call(command, cwd=build_dir, verbose=verbose)
            command = ['make', 'install']
            verbose_check_call(command, cwd=build_dir, verbose=verbose)
        else:
            short_version = '%(major)s.%(minor)s' % version
            cmake_directory = osp.join(dir_manager.directory, 'share', '%s-%s' % (module, short_version), 'cmake')
            components = dir_manager.cache['workers']['brainvisa-cmake']['components'][module] = {
                'source_directory': source_directory,
                'version': full_version,
                'cmake_directory': cmake_directory}

    @classmethod
    def terminate_configure(cls, dir_manager, verbose):
        # Create bv_maker.cmake file
        sorted_components = dir_manager.cache['workers']['brainvisa-cmake']['components']
        cmakeFile = osp.join(dir_manager.directory, 'bv_maker.cmake')
        out = open( cmakeFile, 'w' )
        print >> out, 'set( BRAINVISA_PROJECTS build CACHE STRING "BrainVISA Projects list" FORCE )'
        print >> out, 'set( _BRAINVISA_PROJECTS build CACHE STRING "BrainVISA Projects list" FORCE )'
        print >> out, 'set( BRAINVISA_COMPONENTS', ' '.join(sorted_components),'CACHE STRING "BrainVISA components list" FORCE )'
        print >> out, 'set( _BRAINVISA_COMPONENTS', ' '.join(sorted_components),'CACHE STRING "BrainVISA components list" FORCE )'
        print >> out
        for component, component_cache in sorted_components.iteritems():
            print >> out, 'set( BRAINVISA_SOURCES_' + component + ' "' + cls.cmake_path(component_cache['source_directory']) + '" CACHE STRING "Sources directory for component ' + component + '" FORCE )'
            print >> out, 'set( ' + component + '_DIR "' + cls.cmake_path(component_cache['cmake_directory']) + '" CACHE STRING "Directory used for find_package( ' + component + ' )" FORCE )'
            print >> out, 'set( ' + component + '_VERSION "' + component_cache['version'] + '" )'
        out.close()

        cmakeLists = osp.join( dir_manager.directory, 'CMakeLists.txt' )
        out = open( cmakeLists, 'w' )
        print >> out, '''
cmake_minimum_required( VERSION 2.6 )
set( CMAKE_PREFIX_PATH "${CMAKE_BINARY_DIR}" ${CMAKE_PREFIX_PATH} )
find_package( brainvisa-cmake NO_POLICY_SCOPE )
include( "${brainvisa-cmake_DIR}/brainvisa-compilation.cmake" )
'''
        out.close()
        
        command = cls.cmake_command()
        
        build_type = dir_manager.cache['workers']['brainvisa-cmake']['cmake_build_type']
        command += ['-DCMAKE_BUILD_TYPE:STRING=' + build_type, cls.cmake_path(dir_manager.directory)]

        # set bv_maker path, so that cmake finds its modules
        os.environ['PATH'] = osp.join(dir_manager.directory, 'bin') + osp.sep \
            + os.getenv('PATH')
        verbose_check_call(command, cwd=dir_manager.directory, verbose=verbose)
  
  
    @classmethod
    def start_build(cls, dir_manager, verbose):
        pass
    
    @classmethod
    def build_module(cls, dir_manager, verbose, module):
        pass
    
    @classmethod
    def terminate_build(cls, dir_manager, verbose):
        # TODO manage make options
        command = ['make']
        verbose_check_call(command, cwd=dir_manager.directory, verbose=verbose)

  #def doc( self ):
    #self._process_configuration_lines()
    #system( cwd=self.directory, *( ['make'] + self.make_options.split() + ['-j1', 'doc'] ) )
  
  #def test( self ):
    #self._process_configuration_lines()
